# Development Workflow & Coding Guidelines - SOP (Standard Operating Procedure)

This document outlines the standard development workflow and coding guidelines for this project, functioning as a Standard Operating Procedure (SOP). Adhering to these principles ensures code quality, maintainability, collaboration, and a predictable development process.

**I. Project Planning (Phase 1): Foundation of all Development**

1.  **High-Level Planning:** For each feature or bug fix, start with a clear, high-level plan. This plan will guide all subsequent steps. Create a `plan.md` file to document the plan. The plan should include:

    *   A clear description of the high level problems
    *   Proposed technical approach.
    *   Identifying all subtasks to implement solution.
    *   Consider and update `requirements.txt` for any new dependencies.

2.  **GitHub Issue Creation:** For each identified subtask, create a new issue on GitHub. Each subtask should have all details as a github ticket
The planning will be a guide to implmenation, to save implementation and debugging time.
        Use the following template for each issue:

        ```
        ## Issue: [Concise Title of the Task]

        **Issue Number:** #[Issue Number (auto-generated by GitHub)]

        **Category:** [Feature | Bug | Enhancement | Documentation | Refactor | Testing] *(Choose one)*

        **Priority:** [High | Medium | Low] *(Set based on importance/urgency)*

        **Assignee:** [@username (Assign to the developer who will work on this)]

        **Labels:** [Add relevant labels, e.g., "frontend", "backend", "api", "database"]

        **Milestone:** [Associate with a relevant milestone, e.g., "Sprint 1", "Release 2.0"]

        ---

        ### 1. Description

        *   Provide a clear and concise description of the task or problem this issue addresses. What needs to be done? What is the goal?

        ### 2. User Story (If Applicable - for Features)

        *   As a [user role], I want [desired action] so that [benefit/value].
            *   Example: "As a registered user, I want to be able to reset my password so that I can regain access to my account if I forget it."

        ### 3. Acceptance Criteria

        *   List the specific criteria that must be met for the issue to be considered complete and the solution to be successful. This is the checklist used to verify the issue is resolved. Use bullet points for clarity.
            *   Example:
                *   [ ] A "Forgot Password" link is present on the login page.
                *   [ ] The user receives an email with a password reset link.
                *   [ ] The reset link is valid for 24 hours.
                *   [ ] The user can successfully set a new password using the reset link.
                *   [ ]  The user is redirected to the login page after successfully resetting the password.
                *   [ ]  The reset password functionality is tested with various user roles.

        ### 4. Technical Details / Implementation Notes

        *   Provide any relevant technical information, implementation guidelines, or specific technologies that should be used.
            *   Example:
                *   Use the existing `send_email` function in the `utils` module for sending password reset emails.
                *   The password reset token should be stored securely in the database.
                *   Consider using the `bcrypt` library for password hashing.

        ### 5.  Steps to Reproduce (If Applicable - for Bugs)

        *   If this issue is about a bug, provide clear, step-by-step instructions on how to reproduce the bug. The more detail, the better!
            1.  Go to the login page.
            2.  Enter an invalid username and password.
            3.  Click the "Login" button.
            4.  Observe that the error message is not displayed correctly.

        ### 6.  Expected Behavior

        *   Describe the expected behavior of the system after the issue is resolved.
            *   Example: When the user enters an invalid username or password, a clear and user-friendly error message should be displayed, informing them of the incorrect credentials.

        ### 7.  Screenshots / Mockups (If Applicable)

        *   Include any relevant screenshots or mockups to illustrate the desired functionality or the bug. This is especially useful for UI/UX issues. Use the Markdown image syntax: `![Alt text](image URL)`

        ### 8.  Dependencies

        *   List any other issues, pull requests, or tasks that are dependent on this issue. This helps to manage dependencies and avoid conflicts.
            *   Example: This issue depends on the successful completion of issue #123 (Database Schema Update).

        ### 9.  Out of Scope

        *   Clearly define what is *not* included in this issue. This helps prevent scope creep and keeps the focus on the core task.
            *   Example: This issue does *not* include implementing two-factor authentication.

        ### 10. Notes / Considerations

        *   Add any additional notes, considerations, or potential challenges that the developer should be aware of.
            *   Example: Be mindful of potential security vulnerabilities when handling password reset tokens.

        ---

        **[If you have any questions or need clarification, please comment below.]**
        ```

        *   **For long issue descriptions:** If your issue body is very long or complex, consider writing it in a separate file (e.g., `issue_body.md`) and then using the `--body-file` flag:
            ```bash
            gh issue create --title "Your Issue Title" --body-file issue_body.md
            ```

**II. Development & Local Testing (Phase 2): Coding Adherence**

1.  **Branching (GitHub Flow):** For each GitHub issue, create a new feature branch from the `main` branch. Use a descriptive name related to the issue number (e.g., `feature/123-add-user-profile`).

2.  **Coding Guidelines:** Adhere to the following guidelines during development:

    *   **Dependency Management:**
        *   Always update `requirements.txt` when adding, removing, or updating Python packages.
        *   Ensure `requirements.txt` accurately reflects all project dependencies.

    *   **Modularization:** Break down complex tasks into smaller, more manageable modules, classes, and functions. Each module should have a single, well-defined responsibility.
    * Detailed Code Design
  * The approach to solve the specific design plan is well documented.
  * Justifications of code choices well documented.
    *   **Code Style and Comments:**
        *   **Comments are Crucial!** Add comments to explain:
            *   The purpose of modules, classes, and functions.
            *   Complex logic or algorithms.
            *   Any non-obvious code sections.
        *   Use docstrings for all functions and classes to provide API documentation (using the reStructuredText or Google style):

            ```python
            def calculate_average_price(prices: list[float]) -> float:
                """Calculates the average price from a list of prices.

                Args:
                    prices: A list of floating-point numbers representing prices.

                Returns:
                    The average price as a float.

                Raises:
                    ValueError: If the input list is empty.
                """
                if not prices:
                    raise ValueError("Price list cannot be empty.")
                return sum(prices) / len(prices)
            ```

        *   Adhere to the [PEP 8 style guide](https://peps.python.org/pep-0008/).
            *   Use 4 spaces for indentation.
            *   Limit line length to 120 characters.
            *   Use descriptive variable names.

* Implement with test drive devlopment
       * Test-Driven Development (TDD) cycle,
        * Red (Write a test to see that it is failing, then move to red)
        * Green - See that test run successfully.
        * Refactor - Is the code testable, reusable, and working in all cases
3.  **Local Checks (Mandatory Before Committing):** Before committing any changes, always run the following checks locally:
* Local Testing is most important

        * Check to run all test and ensure it all correct
        * Add test to ensure all the cases can run as well

        *   **Linting:** `ruff check .` (Always ensure your code passes `ruff` checks.)
        *   **Formatting:** `ruff format .`
        *   **Testing:** `pytest`
            These tools help ensure code quality and prevent common errors from reaching the CI/CD pipeline. Address any issues reported by these tools before committing.

        *   Tests should cover all normal and error scenarios, plus:
            *   Edge cases: Unusual or extreme inputs that might cause problems. Examples include:
                *   Empty lists or dictionaries.
                *   Very large numbers or strings.
                *   Invalid data types.
            *   Boundary conditions: Values at the limits of acceptable ranges.
            *   Error Handling: Ensure test cases are added to handle edge cases for API errors etc.

     * **Integration Tests (Local Execution):**

        *   When working with external APIs, integration tests *must* be run locally before pushing any changes, as Github cicd does not provide integration tests functionality. This ensures that the code properly interacts with the service (and API Keys can be stored in your system). Do not run the integration test on cicd on github.
        *   Before Committing/ pushing, ensure that all unit and integration tests can pass

    *   **Detailed Commit Messages:** Every commit tells a story.
        *   Use the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) format: `type(scope): description`
            *   `type`: `feat`, `fix`, `chore`, `docs`, `style`, `refactor`, `test`, `build`, `ci`, `perf`
            *   `scope`: (optional) The module or area of the codebase affected by the commit (e.g., `auth`, `api`, `database`).
            *   `description`: A brief description of the changes.
        *   Examples:
            *   `feat(auth): Implement user login`
            *   `fix(api): Correct error handling for invalid symbol`
            *   `chore: Update dependencies in requirements.txt`
            *   `docs: Add installation instructions to README.md`
        *   If the commit closes an issue, include `Closes #<issue_number>` at the *end* of the commit message.
        *   **For detailed commit messages:** If your commit message is long or requires multiple lines, write it in a separate file (e.g., `commit_message.txt`) and then use the `-F` flag:
            ```bash
            git commit -F commit_message.txt
            ```

**III. Submission, Review, and Integration (Phase 3): Ensuring Quality and Collaboration**

1.  **Pull Request**: A Pull Request (PR) is created to merge the feature branch into the `main` branch.

    *   **Pull Request Description:** The PR description is *critical* for helping reviewers understand your changes. It should include:

        *   **Summary:** A high-level overview of what the PR accomplishes (e.g., "Implements basic user authentication").
        *   **Motivation:** Explain *why* these changes are necessary (e.g., "Fixes a security vulnerability, enables a new feature").
        *   **Detailed Changes:**
            *   A summary of the modules and files affected.
            *   A description of the new code.
            *   A description of changes to existing code.
            *   Focus on "Why" over "What" (Especially in 'Detailed Changes'): While the existing description outlines what was changed, it could better explain why those changes were necessary or the impact of those changes.
            *   Clarify inputs, outputs, and exceptions:
            *   Clarifying the exact input data the functions needs, and how what exceptions were created or handed to prevent problems

            *   **Testing Details:**
            *   An explanation of how the changes were tested (e.g., "Added unit tests, manually tested the UI").
            *   We want to have the tests to check data, input, model, schema and ensure that it can be easy for a 3rd party to look at it
            *   Specific instructions for reviewers on how to test the changes, including environment configurations etc.
            *   A link to documentation.
        *   **Known Issues/Limitations:** If there are any known issues or limitations with the changes, clearly document them.
        *   **Dependencies:** List any other issues, pull requests, or tasks that are related to this PR.
        *   Example description:

            ```
            This PR implements basic user authentication (Issue #123).

            Motivation:
            Enables users to log in to the application with a username and password.

            Detailed Changes:
            - Added `auth.py` module with `User` model and authentication logic.
            - Updated `api.py` to add `/login` endpoint.
            - Created `tests/test_auth.py` with unit tests for authentication functions.

            Testing Details:
            - Added unit tests to `tests/test_auth.py` to cover all authentication functions (login, logout, password reset).
            - Manually tested the login flow through the UI.
            - Added integration tests (run locally) to check the connection to the database.

            -Link to setup DB instructions

            Known Issues:
            - Does not yet support two-factor authentication.

            Dependencies:
            - Depends on issue #122 (Database schema update).
            ```

    *   Consider creating a checklist in the PR description for reviewers to use (e.g., using Markdown checklists).
    *   For large changes, consider breaking them into smaller, more focused pull requests.
    *   **For long PR descriptions:** If your PR body is very long or complex, consider writing it in a separate file (e.g., `pr_body.md`) and then using the `--body-file` flag:
        ```bash
        gh pr create --title "Your PR Title" --body-file pr_body.md
        ```

6.  **Review the Local testing with a Senior Dev:** Have the senior dev review the Local runs, which will add an extra layer before submission.

7.  **CI/CD Pipeline**: The CI/CD pipeline automatically runs on the PR to execute tests and checks, ensuring the changes are safe to merge. **Crucially, ensure all CI/CD checks pass before proceeding.**

    *   Check the "Actions" tab on the PR to view the CI/CD status.
    *   Click on the workflow run to view detailed logs and identify any errors. Address those errors.

8.  **Human Review**: Once all automated CI/CD checks pass, request a human review of the Pull Request. This step is vital for catching logical errors, design flaws, and ensuring code quality that automated tests might miss. Look at the tests and code and ensure that the tests actually tests all areas of code. Look at the code to confirm that there isn't any logic problems and other bugs.

9.  **Merge**: After successful human review and all CI/CD checks pass, the pull request is merged into the `main` branch.

10. **Automatic Issue Closing**: Upon merging, GitHub detects the "fixes #42" keyword in the commit message and automatically closes the corresponding issue.

11. **Post Deployment Checks:** Before proceeding to the next issue, test to ensure all is working as intended with local deployment.